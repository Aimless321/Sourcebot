import db from "../models";
import {recruitRoleId, roleNotificationConfirmationChannel, timeoutRoleId} from "../../config.json";
import {generateMemberWelcome, generateRecruitWelcome} from "../modules/welcomeMessage";
import {GuildMember} from "discord.js";

async function handleTimeout(member: GuildMember) {
    await member.roles.remove(timeoutRoleId);
    // Timeout for 5 minutes
    try {
        await member.timeout(5 * 60 * 1000, 'They are a counting cunt');
        console.log('Handed out a timeout to', member.displayName);
    } catch (e) {
        console.info('Couldn\'t hand out timeout to', member.displayName);
    }
}

export default {
    name: 'guildMemberUpdate',
    async execute(oldMember: GuildMember, newMember: GuildMember) {
        const oldRoles = oldMember.roles.cache;
        const newRoles = newMember.roles.cache;
        const roleDiff = newMember.roles.cache.difference(oldRoles);
        const newIds = roleDiff.map(role => role.id);

        const {Recruit, RoleNotification} = db;

        // Member added to recruits
        if (!oldRoles.has(recruitRoleId) && newRoles.has(recruitRoleId)) {
            const now = new Date();
            const oneMonthFromNow = new Date(new Date().setMonth(now.getMonth() + 1));

            await Recruit.upsert({
                discordId: newMember.id,
                guildId: newMember.guild.id,
                periodStart: now,
                periodEnd: oneMonthFromNow,
                notificationSent: false
            });
        }

        // Removed from recruits
        if (oldRoles.has(recruitRoleId) && !newRoles.has(recruitRoleId)) {
            await Recruit.destroy({where: {discordId: newMember.id}});
        }

        if (newIds.includes(timeoutRoleId)) {
            await handleTimeout(newMember);
        }

        const models = await RoleNotification.findAll({
            where: {
                role: newIds
            }
        });

        models.forEach(model => {
            if (!newRoles.has(model.role)) {
                return;
            }

            const role = roleDiff.get(model.role);
            const channels = newMember.guild.channels.cache;
            const confirmationChannel = channels.get(roleNotificationConfirmationChannel);

            newMember.send(JSON.parse(model.message)).then(() => {
                confirmationChannel.send({
                    embeds: [{
                        title: "Succesfully sent role notification",
                        description: `${role.name} notifcation sent to ${newMember.toString()}`,
                        color: 501760
                    }]
                });
            }).catch(err => {
                console.error(err);
                confirmationChannel.send({
                    embeds: [{
                        title: "Failed to send role update message",
                        description: `Cannot send message to ${newMember.toString()} for ${role.toString()}`,
                        color: 16711680
                    }]
                });
            });

            if (!model.channel) {
                return;
            }

            let announcementChannel = channels.get(model.channel);

            let welcomeGenerator;
            if (role.id === recruitRoleId) {
                welcomeGenerator = generateRecruitWelcome;
            } else {
                welcomeGenerator = generateMemberWelcome;
            }

            welcomeGenerator(newMember.displayName).then(message => {
                announcementChannel.send({
                    content: newMember.toString(),
                    embeds: [{
                        description: `**Welcome ${newMember.displayName} to the ${role.toString()}!**\n\n${message}`,
                        color: 4813784
                    }],
                    footer: {
                        text: 'Disclaimer: This message was generated by AI'
                    },
                    thumbnail: {
                        url: newMember.guild.iconURL()
                    }
                });
            });
        });
    },
};

